import { PrismaClient } from '@/generated/prisma';
import { randomBytes } from 'crypto';
import fetch from 'node-fetch';

import { prisma } from "@/lib/instantiatePrisma"

// Map to keep track of auto-increment counters per workflow ID
let autoIncrementCounter = new Map<string, number>();

/**
 * Generates a serial code based on the given pattern, index, and workflow ID.
 * Supports custom increment patterns or falls back to autogenerated codes.
 * 
 * @param pattern - The serial pattern string which can include special tokens
 * @param index - The index number for multiple generated codes in a batch
 * @param workflowId - The workflow ID to keep auto-increment counters separate
 * @returns A generated serial code string based on the pattern or fallback logic
 */
const generateSerialCode = (
  pattern: string | null | undefined,
  index: number,
  workflowId: number
): string => {
  const randomSuffix = randomBytes(4).toString('hex'); // random hex suffix for uniqueness
  const timestamp = Date.now(); // current timestamp for uniqueness

  if (!pattern) {
    // If no pattern provided, return a default autogenerated code
    return `autogen-${timestamp}-${index}-${randomSuffix}`;
  }

  // Match legacy increment pattern: increment(start)(max)
  const incrementMatch = pattern.match(/increment\((\d+)\)\((\d+)\)/);
  if (incrementMatch) {
    const startNum = parseInt(incrementMatch[1], 10);
    const maxNum = parseInt(incrementMatch[2], 10);
    // Get current increment counter or start from startNum
    const current = autoIncrementCounter.get(workflowId.toString()) ?? startNum;

    if (current > maxNum) {
      // Reset counter if max exceeded
      autoIncrementCounter.set(workflowId.toString(), startNum + 1);
      // Replace pattern with start number
      return pattern.replace(/increment\(\d+\)\(\d+\)/, startNum.toString());
    } else {
      // Increment counter and replace pattern with current number
      autoIncrementCounter.set(workflowId.toString(), current + 1);
      return pattern.replace(/increment\(\d+\)\(\d+\)/, current.toString());
    }
  }

  // Match new style autoincrement pattern: {autoincrement(start)}
  const autoMatch = pattern.match(/\{autoincrement\((\d+)\)\}/);
  if (autoMatch) {
    const startNum = parseInt(autoMatch[1], 10);
    const current = autoIncrementCounter.get(workflowId.toString()) ?? startNum;
    // Increment and store the current counter
    autoIncrementCounter.set(workflowId.toString(), current + 1);
    // Replace pattern token with current counter value
    return pattern.replace(/\{autoincrement\(\d+\)\}/, current.toString());
  }

  // If pattern contains '*', replace it with unique timestamp + index + random hex
  if (pattern.includes('*')) {
    return pattern.replace('*', `${timestamp}-${index}-${randomSuffix}`);
  }

  // Fallback autogenerated code if no pattern matched
  return `generated-${timestamp}-${index}-${randomSuffix}`;
};

/**
 * Checks all enabled workflows optionally filtered by organisation ID,
 * evaluates their conditions, and executes their associated actions.
 * 
 * @param organisationId - Optional organisation ID to filter workflows by organisation
 */
export const checkAndExecuteWorkflows = async (organisationId?: number) => {
  // Fetch all enabled workflows with related product, items, and label data
  const workflows = await prisma.workflow.findMany({
    where: { 
      enabled: true,
      ...(organisationId && { product: { organisationId } }) // conditional filter
    },
    include: {
      product: { include: { items: true } },
      label: true,
    },
  });

  // Iterate over each workflow to evaluate and act on triggers
  for (const workflow of workflows) {
    const product = workflow.product;
    const items = product.items;

    // Count available and broken items for condition checks
    const availableCount = items.filter(i => i.status === 'AVAILABLE').length;
    const brokenItems = items.filter(i => i.status === 'BROKEN');

    let shouldRun = false;

    // Check workflow trigger conditions
    switch (workflow.triggerType) {
      case 'quantity_below':
        if (availableCount < (workflow.threshold ?? 0)) shouldRun = true;
        break;
      case 'any_broken':
        if (brokenItems.length > 0) shouldRun = true;
        break;
      default:
        continue; // Skip unsupported triggers
    }

    if (!shouldRun) continue; // Skip if condition not met

    // Execute workflow actions based on actionType
    switch (workflow.actionType) {
      case 'restock':
        const generatedItems = [];
        // Generate restockQuantity number of new items with serial codes
        for (let i = 0; i < (workflow.restockQuantity ?? 0); i++) {
          const code = generateSerialCode(workflow.serialPattern, i, workflow.id);
          generatedItems.push({ serialCode: code });
        }

        // Send a POST request to API to create new items in inventory
        const res = await fetch(`${process.env.NEXTAUTH_URL}/api/core/items`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            productName: product.name,
            items: generatedItems,
          }),
        });

        if (!res.ok) {
          // Log error if item creation fails
          console.error('Failed to restock items:', await res.text());
        }
        break;

      case 'mark_unavailable':
        // Update status of all broken items to 'BROKEN' explicitly
        for (const item of brokenItems) {
          await prisma.item.update({
            where: { id: item.id },
            data: { status: 'BROKEN' },
          });
        }
        break;

      case 'add_label':
        if (workflow.labelId) {
          // Get existing label IDs assigned to the product
          const existingLabels = await prisma.productLabel.findMany({
            where: { productId: product.id },
            select: { labelId: true }
          });

          const existingLabelIds = existingLabels.map(pl => pl.labelId);

          // If label not already assigned, add it
          if (!existingLabelIds.includes(workflow.labelId)) {
            const allLabelIds = [...existingLabelIds, workflow.labelId];

            // Send a PUT request to update product labels
            const response = await fetch(`${process.env.NEXTAUTH_URL}/api/core/products/labels`, {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                productId: product.id,
                labelIds: allLabelIds,
              }),
            });

            if (!response.ok) {
              console.error('Failed to add label:', await response.text());
            }
          }
        }
        break;

      case 'notify':
        // Prepare notification email subject and message based on trigger
        const subject = `Workflow Alert: ${product.name}`;
        let message = '';

        switch (workflow.triggerType) {
          case 'quantity_below':
            message = `Product "${product.name}" has ${availableCount} available items, which is below the threshold of ${workflow.threshold}.`;
            break;
          case 'any_broken':
            message = `Product "${product.name}" has ${brokenItems.length} broken items that need attention.`;
            break;
        }

        // Send notification email via internal SMTP API
        const response = await fetch(`${process.env.NEXTAUTH_URL}/api/smtp`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            to: 'aleksandurkolev80@gmail.com',
            subject,
            text: message,
            html: `<p>${message}</p>`,
          }),
        });

        if (!response.ok) {
          console.error('Failed to send notification:', await response.text());
        }
        break;

      default:
        // Skip unknown actions
        continue;
    }
  }
};

